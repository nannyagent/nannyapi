# NannyAPI Architecture

## System Overview

NannyAPI is the central control plane for Nanny Agents. It handles agent registration, authentication, investigation orchestration, and patch management. The system is built on top of PocketBase, providing a robust backend with real-time capabilities.

## Core Components

### 1. Authentication & Identity
The system supports multiple authentication methods:
- **OAuth2**: Native support for Google and GitHub OAuth providers for user access (Admins/Devs).
- **Agent Authentication**: Token-based authentication for agents.

### 2. AI & Observability Stack
To provide advanced AI capabilities and deep observability, NannyAPI integrates with:

- **TensorZero**: Used as the AI Gateway and LLM orchestration layer. It handles prompt management, model routing, and inference.
  - *Installation*: Please refer to the [TensorZero Documentation](https://www.tensorzero.com/docs) for installation instructions.
  
- **ClickHouse**: Used for high-performance observability data storage.
  - It stores **AI inference logs** and **episodes** generated by TensorZero.
  - **Note**: Currently, ClickHouse is required if you want to fetch AI inference history and episodes. Future releases will make this completely optional, but running without it is currently untested.

### 3. Investigation Workflow

Investigations follow an iterative diagnostic loop before a final resolution is reached.

#### Initiation
1. **Portal Initiated**: Admin triggers investigation -> API creates record -> Agent picks up request.
2. **Agent Initiated**: Agent detects anomaly -> Sends request to API.

#### Diagnostic Loop (Iterative)
1. **Context Collection**: Agent collects initial logs/metrics.
2. **AI Analysis**: Context sent to TensorZero.
3. **Hypothesis & Triage**: AI generates a hypothesis and may request specific **commands** or **eBPF programs** to verify it.
4. **Execution**: Agent executes the safe read-only commands/scripts.
5. **Feedback**: Output is sent back to AI.
6. **Repeat**: This cycle continues until the AI has sufficient confidence.

#### Resolution
Only after the diagnostic loop is complete does the AI generate a final **Resolution Plan**.
- This plan contains the root cause analysis and recommended remediation steps.
- It is stored in the `resolution_plan` field of the investigation record.

### 4. Advanced Diagnostics with eBPF

NannyAPI leverages **bpftrace** for deep system introspection. When standard logs and metrics are insufficient, the AI can generate safe, read-only bpftrace scripts to gather kernel-level insights.

**Example Workflow:**
1. **Issue**: "Application is slow but CPU is low."
2. **AI Hypothesis**: "Possible disk I/O latency or lock contention."
3. **Action**: AI generates a bpftrace one-liner:
   ```bash
   bpftrace -e 'tracepoint:block:block_rq_issue { @ = hist(args->bytes); }'
   ```
4. **Execution**: Agent runs the script for a limited duration (e.g., 10s).
5. **Analysis**: The histogram output is sent back to the AI to confirm if I/O size is the bottleneck.

### 5. Virtualization Support (Proxmox)

NannyAPI includes specialized support for Proxmox VE environments.
- **Host Agents**: Run on Proxmox nodes to monitor the hypervisor.
- **Guest Patching**: Supports agentless patching of LXC containers directly from the host.
- **Topology**: Maintains relationships between Clusters, Nodes, and Guests.

For detailed architecture of the Proxmox integration, see **[Proxmox Integration](PROXMOX.md)**.

### 6. Security & System Prompts

To ensure the safety and reliability of the AI agents:

- **System Prompts**: The core system prompts that govern the AI's behavior are **NOT public**. This is to prevent prompt injection attacks and unauthorized overwrites.
- **Access**: Users wishing to run NannyAPI in a self-hosted environment can request a copy of the system prompts by writing to `support@nannyai.dev`.
- **Future Availability**: Once we have confidently verified the prompts against adversarial attacks and established robust verification mechanisms, they will be made public.

## Architecture Diagram

```mermaid
graph TD
    User[Admin/User] -->|OAuth (Google/GitHub)| API[NannyAPI (PocketBase)]
    Agent[Nanny Agent] -->|Auth Token| API
    
    subgraph "AI & Data Layer"
        API -->|Inference Requests| TZ[TensorZero]
        API -->|Observability Data| CH[(ClickHouse)]
        TZ -->|LLM Calls| LLM[LLM Providers]
    end

    subgraph "Agent Execution"
        Agent -->|1. Report Issue| API
        API -->|2. Send Plan| Agent
        Agent -->|3. Exec Commands/eBPF| System[Host System]
        System -->|4. Result| Agent
    end
```

## Database Schema

The following collections are defined in PocketBase.

### `users`
Standard PocketBase users collection.
- `email`: User email.
- `name`: User full name.
- `avatar`: User avatar.

### `device_codes`
Used for the agent device authentication flow.
- `device_code` (text): Unique code for the device.
- `user_code` (text): Short code for user entry.
- `user_id` (relation -> users): The user who authorized the device.
- `authorized` (bool): Whether the code has been authorized.
- `consumed` (bool): Whether the token has been exchanged.
- `expires_at` (date): Expiration timestamp.
- `agent_id` (text): ID of the agent (if registered).

### `agents`
Registered Nanny Agents.
- `user_id` (relation -> users): Owner of the agent.
- `device_code_id` (relation -> device_codes): Originating auth code.
- `hostname` (text): System hostname.
- `platform` (text): OS platform (linux, darwin, etc.).
- `platform_family` (text): Distro family (debian, rhel, etc.).
- `os_version` (text): OS version string.
- `kernel_version` (text): Kernel version.
- `arch` (text): CPU architecture.
- `version` (text): Agent version.
- `status` (select): active, inactive, revoked.
- `last_seen` (date): Last heartbeat.
- `public_key` (text): SSH public key.
- `ip_address` (text): Remote IP.

### `investigations`
Incident records and AI analysis.
- `user_id` (relation -> users): Initiator.
- `agent_id` (relation -> agents): Target agent.
- `episode_id` (text): TensorZero episode ID.
- `user_prompt` (text): Initial issue description.
- `priority` (text): low, medium, high.
- `status` (text): pending, in_progress, completed, failed.
- `resolution_plan` (text): Final AI-generated remediation plan.
- `initiated_at` (date): Start time.
- `completed_at` (date): End time.
- `metadata` (json): Additional context.

### `scripts`
Versioned patch scripts.
- `name` (text): Script name.
- `description` (text): Description.
- `platform_family` (text): Target family (debian, rhel).
- `os_version` (text): Specific version target.
- `file` (file): The script file itself.
- `sha256` (text): Hash for integrity verification.

### `patch_operations`
Records of patch jobs.
- `user_id` (relation -> users): Initiator.
- `agent_id` (relation -> agents): Target agent.
- `mode` (text): dry-run, apply.
- `status` (text): pending, running, completed, failed.
- `script_id` (relation -> scripts): The script used.
- `script_url` (text): Direct URL to script.
- `output_path` (text): Path to execution logs.
- `error_msg` (text): Error details.
- `exclusions` (json): List of packages excluded from this run.
- `started_at` (date): Execution start.
- `completed_at` (date): Execution end.

### `package_exceptions`
Persistent package exclusions for agents.
- `agent_id` (relation -> agents): Target agent.
- `user_id` (relation -> users): Creator.
- `package_name` (text): Name of package to exclude.
- `reason` (text): Reason for exclusion.
- `expires_at` (date): Optional expiration.
- `is_active` (bool): Toggle status.

## Platform Support

Currently, the diagnostic capabilities are optimized for Linux systems. The roadmap includes support for FreeBSD, Darwin (macOS), and Windows.
